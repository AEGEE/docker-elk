input {
	tcp {
		port => 5000
	}
	udp {
		port => 5000
        codec => json
	}
	beats {
		port => 5044
	}
}

## Add your filters / logstash plugins configuration here
filter {
   
  prune {
     whitelist_names => [ "timestamp", "msg", "message", "loglevel", "docker", "stream", "tags", "statuscode", "method", "type" ]
  }

  if [docker][image] =~ "traefik" {
    if [message] =~ "^time"{
       kv { remove_field => [ "time", "message" ] }
       mutate{ add_field => { "traefik_log_type" => "traefik_log" } }
    }else{
      mutate{ add_field => { "traefik_log_type" => "nginx_log" } }
      grok {
        match => { "message" => ["%{IPORHOST:[nginx][access][remote_ip]} - %{DATA:[nginx][access][user_name]} \[%{HTTPDATE:[nginx][access][time]}\] \"%{WORD:[nginx][access][method]} %{DATA:[nginx][access][url]} HTTP/%{NUMBER:[nginx][access][http_version]}\" %{NUMBER:[nginx][access][response_code]} %{NUMBER:[nginx][access][body_sent][bytes]} \"%{DATA:[nginx][access][referrer]}\" \"%{DATA:[nginx][access][agent]}\""] }
        remove_field => [ "message", "[nginx][access][time]" ]
      }
      useragent {
        source => "[nginx][access][agent]"
        target => "[nginx][access][user_agent]"
        remove_field => "[nginx][access][agent]"
      }
      geoip {
        source => "[nginx][access][remote_ip]"
        target => "[nginx][access][geoip]"
      } 
    }

  }

  if [docker][image] =~ "kibana"{
       grok {
         match => { "message" => "%{WORD:verb} %{NOTSPACE:request} %{NUMBER:response} %{GREEDYDATA:kibana_stuff}" }
         remove_field => "message"
       }
  }

  if [docker][image] =~ "elasticsearch"{
      grok {
              match => [ "message", "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:loglevel}%{SPACE}\]\[%{DATA:source}%{SPACE}\]%{SPACE}\[%{DATA:node}\]%{SPACE}\[%{DATA:index}\] %{NOTSPACE} \[%{DATA:updated-type}\]",
                        "message", "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:loglevel}%{SPACE}\]\[%{DATA:source}%{SPACE}\]%{SPACE}\[%{DATA:node}\] (\[%{NOTSPACE:Index}\]\[%{NUMBER:shards}\])?%{GREEDYDATA}"
                       ]
              remove_field => [ "message", "timestamp" ]
      } 
#       dissect {
#          mapping => {
#               "message" => "%{timestamp} %{loglevel} %{} %{} %{} %{} %{msg}"
#          }  
#       }
  }

  if [tags] =~ "beat" {
#     prune {
#        blacklist_names#NB this prunes field from an object, not values from an array.. i think
#     }
      mutate{ add_field => { "porco" => "dio" } }
  }

#todo: aggregate stuff from NPM

#  translate {
#    field => "response_code"
#    destination => "http_response"
#    dictionary => {
#      "200" => "OK"
#      "403" => "Forbidden"
#      "404" => "Not Found"
#      "408" => "Request Timeout"
#    }
#  }

}

output {
	elasticsearch {
		hosts => "elasticsearch:9200"
        #if [tags][]{manage_template => false
   # index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}" 
   # document_type => "%{[@metadata][type]}"} ###https://www.elastic.co/guide/en/logstash/current/plugins-inputs-beats.html
	}
}
